"""Convert WitMotion binary to CSV

Ingests the binary file generated by a run of the WitMotion WT901SD.
Converts that to a CSV for use with other tools (for analysis etc.).
Equations for conversions etc. came from the datasheet (WT901
Datasheet.pdf) currently served in the repository at:

git@github.com:WITMOTION/WT901.git

"""
import argparse
import csv

parser = argparse.ArgumentParser()
parser.add_argument("filename")
parser.add_argument("outfile")
args = parser.parse_args()


def write_csv(prepared_data, output_filename):
    """Write out the CSV file from the prepared data

    The prepared data is a list of lists, each of the latter is of all
    the elements that constitute a whole sample from the IMU and thus
    a row in the the resultant CSV.

    """
    with open(output_filename, 'w', encoding='utf-8') as outfile:
        writer = csv.writer(outfile,
                            delimiter=',',
                            quotechar='"',
                            quoting=csv.QUOTE_MINIMAL)

        header_names = ['a_x', 'a_y', 'a_z', 'w_x', 'w_y', 'w_z',
                        'angle_x', 'angle_y', 'angle_z', 'mag_x',
                        'mag_y', 'mag_z']
        writer.writerow(header_names)
        for row in prepared_data:
            writer.writerow(row)


def process_timestamp_message(message):
    """Generate timestamp from bytes in timestamp message

    """
    print(message)


def calc_accel(two_bytes):
    """Do math for acceleration value calculation

        Based on the equation in the WitMotion datasheet

    """
    return int.from_bytes(two_bytes, "little", signed=True)/32768*16


def calc_w(two_bytes):
    """Do math for angular velocity value calculation

    Based on the equation in the WitMotion datasheet

    """
    return int.from_bytes(two_bytes, "little", signed=True)/32768*2000


def calc_angle(two_bytes):
    """Do math for angle value calculation

    Based on the equation in the WitMotion datasheet

    """
    return int.from_bytes(two_bytes, "little", signed=True)/32768*180


def calc_magnetic(two_bytes):
    """Do math for magnetic value calculation

    Based on the equation in the WitMotion datasheet

    """
    return int.from_bytes(two_bytes, "little", signed=True)


def process_data_message(message, calc_function):
    """Apply supplied conversion function to data payload of message

    The data payload of the four sensor type messages is structured so
    (i.e. in 3 pairs of bytes for each of x, y, and z parts) that it
    can be handled by this function given a function (calc_function)
    that does the particular math associated with the sensor data in
    question.

    """
    x_part = calc_function(message[2:4])
    y_part = calc_function(message[4:6])
    z_part = calc_function(message[6:8])

    return x_part, y_part, z_part


def main():  # pylint: disable-msg=too-many-locals
    """Main function

    """
    with open(args.filename, 'rb') as data_file:
        data = data_file.read()

    # remove "preamble": everything up to first 0x55
    while hex(data[0]) != '0x55':
        data = data[1:]

    # break remaining data up into 10 bytes pieces. big assumption
    # that nothing will break this pattern in the data.  On test data,
    # checked that every frame began with 0x55 and it did.  NOTE: very
    # last frame could very easily be partial
    messages = [data[i:i+11] for i in range(0, len(data), 11)]

    # first line of messages does not begin with a 0x50 (i.e. doesn't
    # have a timestamp so just cutting it out.  Not sure if this will
    # be repeatable on other data and therefore might need a more
    # elegant treatment to generalize
    messages = messages[4:]

    prepared_data = []
    first_row = True
    row_of_data = None
    for message in messages:
        if hex(message[1]) == '0x50':
            if not first_row:
                prepared_data.append(row_of_data)
            first_row = False
            row_of_data = []
            # STUFF = process_timestamp_message(message)
            # row_of_data.extend(STUFF)

        if hex(message[1]) == '0x51':
            a_x, a_y, a_z = process_data_message(message, calc_accel)
            row_of_data.extend([a_x, a_y, a_z])

        if hex(message[1]) == '0x52':
            w_x, w_y, w_z = process_data_message(message, calc_w)
            row_of_data.extend([w_x, w_y, w_z])

        if hex(message[1]) == '0x53':
            angle_x, angle_y, angle_z = process_data_message(message,
                                                             calc_angle)
            row_of_data.extend([angle_x, angle_y, angle_z])

        if hex(message[1]) == '0x54':
            mag_x, mag_y, mag_z = process_data_message(message, calc_magnetic)
            row_of_data.extend([mag_x, mag_y, mag_z])

    write_csv(prepared_data, args.outfile)


if __name__ == "__main__":
    main()
